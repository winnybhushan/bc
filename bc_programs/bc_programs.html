<html>
<head>
<link rel="shortcut icon" href="http://www.numbertheory.org/gnubc/favicon_gbc.ico" type="image/x-icon"> 
<title>
BC NUMBER THEORY PROGRAMS
</title>
<STYLE TYPE="text/css">
<!--
body { font-family: Helvetia, sans-serif}
A:visited { text-decoration: none }
A:link {text-decoration: none}
A:hover {text-decoration: underline}
H3 {text-align: center}
-->
</STYLE>
</head>
<body bgcolor="FFFFFF">
<!--<font face=arial,helvetica size=-1>-->
<h3>BC number theory programs</h3>
<small>
<hr>
<ol>
<li><a href="./gcd"><strong>gcd:</strong></a>
<ul>
<li> <tt>sign(n)</tt>.
<li> <tt>abs(n)</tt>.
<li> <tt>mod(a,b)</tt>, (b &gt; 0): returns a(mod b).
<li> <tt>int(a,b)</tt>:  returns the integer part of a/b, b nonzero.
<li> <tt>gcd(m,n)</tt>.
<li> <tt>gcd1(m,n)</tt>: gcd(m,n)=gcd1(m,n)&middot;m+gcd2(m,n)&middot;n.
<li> <tt>gcd2(m,n)</tt>.
<li> <tt>lcm(m,n)</tt>.
<li> <tt>inv(a,n)</tt>: returns the inverse of a mod m.
<li> <tt>cong(a,b,m)</tt>: solves ax &equiv; b (mod m).
<li> <tt>chinese(a,b,m,n)</tt>: solves x &equiv; a(mod m) and x &equiv; b(mod n).
<li> <tt>gcda(m[],n)</tt>: finds gcd(m[0],...,m[n-1]) and expresses it
     as a linear combination of m[0],...,m[n-1].
<li> <tt>lcma(m[],n)</tt>: finds lcm(m[0],...,m[n-1]).
<li> <tt>chinesea(a[],m[ ],n)</tt>: solves x &equiv; a[i](mod m[i]), i=1,...,n-1.
<li> <tt>chineseb(a[],b[],m[],n)</tt>: solves a[i]x &equiv; b[i](mod m[i]),
     i=1,...,n-1.
<li> <tt>mpower(a,b,c)</tt>: returns a<sup>b</sup> (mod c).
<li> <tt>exp(a,b)</tt>: returns a<sup>b</sup>.
<li> <tt>mthroot(a,b,m)</tt>: returns the integer part of the mth-root of a/b. 
     Here a,b and m are positive integers, m &gt; 1.  (See K.R. Matthews, <a href="../keith/mthroot.html"><em>Computing mth roots</em></a>, College Mathematics Journal 19 (1988) 174-176.)
<li> <tt>mthrootr(a,b,m,r)</tt>: this gives the mth-root of a/b 
truncated to r places.
<li><tt>binomial(n,m)</tt>: returns the binomial coefficient.
<li><tt>gcd3(a,b,c)</tt>: returns gcd(a,b,c).
</ul>
<li><a href="./euclid"><strong>euclid</strong></a>: <tt>euclid(m,n)</tt> performs Euclid's algorithm.
<li><a href="./euclid1"><strong>euclid1</strong></a>: <tt>euclid(m,n)</tt> returns the length of Euclid's algorithm.
<li><a href="./jacobi"><strong>jacobi</strong></a>:
<ul>
<li><tt>jacobi(m,n)</tt> calculates the Jacobi symbol
<li><tt>peralta(a,p)</tt> finds a square root of a quadratic 
residue a mod p, using an algorithm of Rene Peralta.
</ul>
<li><a href="./serret"><strong>serret</strong></a>: <tt>serret(p)</tt> expresses a prime of the form 
4n+1 as the sum of two squares using Serret's algorithm.
<li><a href="./3x+1"><strong>3x+1</strong></a>: <tt>collatz(n)</tt> tests the 3x+1 conjecture.
<li><a href="./3x+371"><strong>3x+371</strong></a>: <tt>s(n)</tt> tests the 3x+371 conjecture.
<li><a href="./phi"><strong>phi</strong></a>: (slow-uses Brent-Pollard only)
<ul>
<li> <tt>omega(n)</tt> returns the number of distinct prime factors of n.
<li> <tt>phi(n)</tt> returns the value of Euler's function.
<li> <tt>tau(n)</tt> returns the number of divisors of n.
<li> <tt>sigma(n)</tt> returns the sum of the divisors of n.
<li> <tt>mu(n)</tt> returns the value of the Mobius Function.
<li> <tt>lprimroot(p)</tt> returns the least primitive root mod p.
<li> <tt>orderm(a,m)</tt> returns the order of a mod m.
</ul>
<li><a href="./factors"><strong>factors</strong></a>: <tt>factor(n)</tt> attempts to factor n using 
         Brent-Pollard (slow).
<li><a href="./lucas"><strong>lucas</strong></a>: <tt>lucas(n)</tt> performs the strong base 2 
         pseudoprime test and Lucas pseudoprime test on n.<br>
         (Needs <tt>jacobi</tt>).
<li><a href="./decimal"><strong>decimal</strong></a>: <tt>period(m,n,b)</tt> outputs the period 
         digits of the base b expansion of m/n, where m,n,b (b &gt; 1) are 
	 positive integers, 1&le;m &lt; n. 
<li><a href="./pell"><strong>pell</strong></a>: <tt>pell(d,e)</tt> finds the least solution of Pell's
         equations x<sup>2</sup>-d*y<sup>2</sup>=&#177;1,&plusmn;2,&plusmn;3 and least primitive solution of x<sup>2</sup>-d*y<sup>2</sup>=&plusmn;4. If e=1, the complete and partial quotients are printed; if e=0, this detail is suppressed.
<li><a href="./surd"><strong>surd</strong></a>: <tt>surd(d,t,u,v)</tt> finds the continued fraction
         expansion of a quadratic irrational (u+t*sqrt(d))/v, where d &gt; 1 is not a square, t,u,v integers, v nonzero.
<li><a href="./unit"><strong>unit</strong></a>: <tt>unit(d)</tt> finds the fundamental unit of 
         Q(sqrt(d)).
<li><a href="./fibonacci"><strong>fibonacci</strong></a>: <tt>f(m,n)</tt> prints the Fibonacci numbers
         F(m),...,F(n). l(m,n) prints the Lucas numbers L(m),...,L(n).
<li><a href="./rootd"><strong>rootd</strong></a>: <tt>root(d)</tt> finds the continued fraction
         expansion of sqrt(d).
<li><a href="./cfrac"><strong>cfrac</strong></a>: <tt>cfrac(m,n)</tt> finds the continued fraction
         expansion of m/n.
<li><a href="./proth"><strong>proth</strong></a>: <tt>proth(h,m)</tt> investigates the primality of
         h*2<sup>m</sup>+1, h &lt; 2<sup>m</sup>, using Proth's test.<br>
         (Needs <tt>jacobi</tt>,<tt>lucas</tt>).
<li><a href="./pollard"><strong>pollard</strong></a>: <tt>pollard(n)</tt> attempts to find a factor 
         of n using the Pollard p-1 method.
<li><a href="./3branch"><strong>3branch</strong></a>: <tt>s(n)</tt> tests a 3-branched generalized 3x+1
         conjecture.
<li><a href="./challencge"><strong>challenge</strong></a>: <tt>s(n)</tt> tests another 3-branched 
         generalized 3x+1 conjecture.
<li><a href="./mordell"><strong>mordell</strong></a>: <tt>f(a,k)</tt> finds the integer solutions of 
         y<sup>2</sup>=x<sup>3</sup>+a with x &le; k. (Needs <tt>gcd</tt>.)
<li><a href="./venturini1"><strong>venturini1</strong></a>: <tt>s(n)</tt> tests a 6-branched generalized
         3x+1 function of G. Venturini.
<li><a href="./lra"><strong>lra</strong></a>: (needs <tt>gcd</tt>)
<ul>
<li> <tt>lnearint(m,n)</tt> returns the (left) nearest integer to m/n.
<li> <tt>rnearint(m,n)</tt> returns the (right) nearest integer to m/n.
<li> <tt>lmodd(m,n)</tt> returns the (left) least remainder of sign(n)m mod |n|.
<li> <tt>rmodd(m,n)</tt> returns the right) least remainder of sign(n)m mod |n|.
<li> <tt>lra(m,n)</tt> performs the least remainder algorithm on m, n.
<!--<li> <tt>lbrisse(a,b,n)</tt> calculates a[0]=a,a[1]=b,...,a[n], where a[n+1]=lnearint(a[n]a[n]/a[n-1]), a,b positive integers. Also prints a[n]/a[n-1].
<li> <tt>rbrisse(a,b,n)</tt> calculates a[0]=a,a[1]=b,...,a[n], where a[n+1]=rnearint(a[n]a[n]/a[n-1]), a,b positive integers. Also prints a[n]/a[n-1].-->
<li><tt>nicf(m,n)</tt> prints the nearest integer continued fraction of m/n:
m/n = [a<sub>0</sub> - 1/a<sub>1</sub> - &middot;&middot;&middot; - 1/a<sub>n</sub>].
<br> We write this as (a<sub>0</sub>,a<sub>1</sub>,...,a<sub>n</sub>).
</ul>
<li><a href="./convergents"><strong>convergents</strong></a>: <tt>pn(a[],n)</tt> and <tt>qn(a[],n)</tt> compute the numerator and denominator of the continued fraction [a[0];a[1],...,a[n]].
<li><a href="./lagrange"><strong>lagrange</strong></a>: <tt>lagrange(a[],n,m)</tt> 
uses the method of Lagrange (1797) to find the first m+1 partial
quotients of t, where f(x)=a[n]x<sup>n</sup>+&#183;&#183;&#183;+a[0], a[n] &gt; 0, is a polynomial with integer coefficients, having no rational roots
 and having exactly one real positive root t, this being &gt; 1.
<li><a href="./lupei"><strong>lupei</strong></a>: <tt>s(n)</tt> tests Lu Pei's 3-branched generalized 3x+1 mapping.
<li><a href="./recursion"><strong>recursion</strong></a> (Recursive bc programs)
<ul>
<li><tt>fib(n)</tt>: returns the nth Fibonacci number, n &ge; 0.
<li><tt>luc(n)</tt>: returns the nth Lucas number, n &ge; 0.
<li><tt>fac(n)</tt>: returns factorial(n) if n &ge; 1.
</ul>
<li><a href="./tonelli"><strong>tonelli</strong></a>: <tt>x=tonelli(a,p)</tt> returns a square root of a (mod p), deterministically.
<li><a href="./discrete_log"><strong>discrete_log</strong></a>: <tt>r=shanks(n,g,p)</tt>. 
Here g is a primitive root (mod p) and g<sup>r</sup> &equiv; n (mod p), 0 &le; r &lt; p-1. <br>
Note: p &lt; 2<sup>32</sup>-2<sup>16</sup>=4294901760, in order to satisy BC array upper bound length of 2<sup>16</sup>-1.<br>
If r does not exist, we return -1.<br>
We use Shanks' giant steps-baby steps approach as described in <a href="http://www.mathematik.uni-muenchen.de/~forster/books/algzth.html"><em>Algorithmische Zahlentheorie</em></a> by Otto Forster, pp 65-66.
<li><a href="./forster_log"><strong>forster_log</strong></a>: <tt>r=shanks(n,g,p)</tt>. 
Similar to <strong>discrete_log</strong>, except that p is no longer necessarily a prime. Now needs <strong>phi</strong> to provide <tt>orderm(a,m)</tt>.
<li><a href="./leastqnr"><strong>leastqnr</strong></a>: <tt>leastqnr(p)</tt> returns n<sub>p</sub>, the least quadratic nonresidue mod p. (Needs <tt>gcd</tt>).
<!--<li><strong>log</strong>: <tt>log(a,b,d,u,v)</tt>, a &gt; b &gt; 1, d &gt; 1, u &gt; v &ge; 1 outputs a sequence of integers that are likely to be the initial partial quotients of log(a)/log(b) if u,v are large.  See manuscript <a href="../../pdfs/log.pdf">log.pdf</a>.
<li><strong>log1</strong>: <tt>log1(a,b,d,r,e)</tt> performs a discrete variant  of Shank's log<sub>b</sub>a algorithm.  Here 1&lt; r is an integer. Also d &gt; 1.  We do not guarantee the correctness of the output. Bigger d give more partial quotients. Roughly r partial quotients seem to be outputted when d=10.<br>
 If e=1, the convergents, the integers A[i] and decimal expansion of log<sub>b</sub>a are printed, the latter truncated correct to as many decimal places as possible: the r-1th convergent is compared with the rth convergent and the decimal expansions are truncated from where they differ.  e=0 prints only the partial quotients.-->
<li><a href="./rootd_modn"><strong>rootd_modn</strong></a>: <tt>rootd_modn(d,n)</tt> finds all solutions of the congruence x<sup>2</sup> &equiv; d (mod n) with 0 &le; x &le; n/2 for small n.
<li><a href="./thue"><strong>thue</strong></a>:  Here d>1, is not a square, n &gt; 1 an odd integer not dividing d-1. u<sup>2</sup> &equiv; d (mod n), 1 &lt; u &lt; n. Then <tt>thue(d,u,p)</tt> finds x,y such that x<sup>2</sup>-dy<sup>2</sup>=kn, with small k.
<li><a href="./sqroot"><strong>sqroot</strong></a>: <tt>sqroot(d,n)</tt>, n &gt; 1, finds all solutions of x<sup>2</sup> &equiv; d (mod n). It returns -1 if there is no solution, otherwise returns the number of solutions (mod n).
<li><a href="./tomas1"><strong>tomas1</strong></a> and <a href="./tomas2"><strong>tomas2</strong></a>: These are generalised 3x+1 examples studied by Tom&aacute;s Oliveira e Silva, where all trajectories are eventually periodic.
<li><a href="./log"><strong>log</strong></a>: <tt>log(a,b,d,r,e)</tt> performs a discrete variant  of Shank's log<sub>b</sub>a algorithm.  Here 1 &lt; r is an integer. Also d &gt; 1.  We do not guarantee the correctness of the output. Bigger (d,r) give more partial quotients. e=1 prints the A[i] and AA[i], while e=0 prints only the m[i] and mm[i]. See <a href="../pdfs/log.pdf">paper</a>.<br>
I suggest the user runs <tt>test(a,b,d,m,n)</tt>, over a range (m,n), where m &le; n, to get an idea of the correct partial quotients. This
runs <tt>log1(a,b,d,r)</tt> for r=m,...,n. 
To get an idea of the correct answer when m=n=r, we recommend taking m=r-t, n=r+t, with 1 &le; t &le; (say) 2.
<li><a href="./base"><strong>base</strong></a>: <tt>f(b,n)</tt>, n &gt; 0, b &gt; 1, gives the base b expansion of n.
<li><a href="./perfect_power"><strong>perfect_power</strong></a>: <tt>perfect_power(n)</tt> produces 0 if n is not a perfect power; otherwise returns x and p, where n=x<sup>p</sup> and p is the least prime with this property.
<li><a href="./primes"><strong>primes</strong></a>: <tt>primes(m,n)</tt> prints the primes in the interval [m,n], if ma and n lie between 1 and 10<sup>10</sup>.
<li><a href="./nprime"><strong>nprime</strong></a>: <tt>nprime(m)</tt> finds the least Lucas-base2 strong pseudoprime p satisfying p &ge; m.
<li><a href="./nprimeap"><strong>nprimeap</strong></a>: <tt>nprimeap(m,a,b)</tt> finds the least Lucas-base2 strong pseudoprime p of the form p=ak+b and satisfying p &ge; m. Here 0 &lt; b &lt; a and gcd(a,b)=1.
<li><a href="./sturm"><strong>sturm</strong></a>: <tt>sturm(a[],n,b,e)</tt> prints a sturm polynomial sequence for the (squarefree) polynomial a[n]x<sup>n</sup>+&middot;&middot;&middot;+a[0], evaluates the sequence at x=b and calculates its sign variation. e=0 suppresses printing.
<li><a href="./john"><strong>john</strong></a>: <tt>johna(b[],n)</tt> takes an array of positive integers b[0],...,b[n-1] and replaces them by an array of positive integers a[0],...,a[n-1], where<br>
<ol>
    <li> a[i] divides b[i] for 0 &le; i &lt; n;
   <li> gcd(a[i],a[j])=1 for 0 &le; i &lt; j&lt; n;
   <li> lcm(b[0],...,b[n-1])=a[0]&middot;a[1]&middot;&middot;&middot;a[n-1].
</ol>
<tt>john(a,b)</tt> does the case n=2.<br>
The program is due to John Campbell. Needs the program <strong>gcd</strong>.
<li><a href="./reducepos"><strong>reducepos</strong></a>: <tt>reduce(a,b,c)</tt> takes as input an indefinite binary quadratic form ax<sup>2</sup>+bxy+cy<sup>2</sup> and uses the PQa algorithm to find a cycle of reduced forms. (See <a href="../pdfs/reduce.pdf">explanation</a>.)
<li><a href="./classnoneg"><strong>classnoneg</strong></a>: <tt>class_number(d,flag,table_flag)</tt> lists the reduced binary quadratic forms of negative discriminant d and returns their number h(d) if <tt>flag</tt>=0. If <tt>flag</tt>=1, only the primitive forms are counted. Only the class number is printed if table_flag=0.<br>
If d is the discriminant of an imaginary quadratic field K, then the primitive forms class-number h(d) is also the class number of K. <br>
Algorithm 5.3.5 of Henri Cohen's <em>A course in computational algebraic number theory</em> is used.<br>
<tt>table(m,n)</tt> prints h(-d) for all squarefree d in the range m &le; d &lt; n,
where n&lt;10<sup>6</sup>.
<li><a href="./reduceneg"><strong>reduceneg</strong></a>: <tt>reduce(a,b,c)</tt> takes as input a positive definite binary quadratic form ax<sup>2</sup>+bxy+cy<sup>2</sup> and uses an algorithm of Gauss to find the equivalent reduced form and unimodular transforming matrix.
<li><a href="./classnopos"><strong>classnopos</strong></a>: <tt>class_number(d)</tt> (1 &lt; d &lt; 10<sup>6</sup> and squarefree) finds the class number of the real quadratic field Q(<img align="middle" src="../gifs/sqrtd.gif">) and the sign of the fundamental unit. A list of reduced binary quadratic forms corresponding to the ideal classes is also given.<br>
<tt>table(m,n)</tt> prints h(d) for all squarefree d in the range m &le; d &lt; n,where n &lt; 10<sup>6</sup>.<br>
<tt>class_number0(d)</tt> (d &gt; 0, not a perfect square and 0 or 1 (mod 4))
 returns the class-number of binary quadratic forms of discriminant d.  Also the solubility of x<sup>2</sup>-d*y<sup>2</sup>=-4 is determined.<br>
This is basically the same program as <tt>class_number(d)</tt>, except that in
the case of non-solubility of x<sup>2</sup>-d*y<sup>2</sup>=-4, we count the form (-a,b,c) as well as (a,b,c), a &gt; 0 and this means we return twice the value that <tt>class_number(d)</tt> would otherwise have returned.  Regarding this point, see G.B. Mathews, <em>Theory of Numbers</em>, pp. 80-81.
<li><a href="./unimodular"><strong>unimodular</strong></a>: <tt>unimodular(p,q,r,s)</tt> expresses a unimodular matrix A &ne; I<sub>2</sub> or U=[0,1,1,0] with non-negative coefficients, as a product of one of the following forms:<br>
P, UP, PU, or UPU, where P is a product of matrices of the form U<sub>a</sub>=[a,1,1,0], a>0.<br>
The representation is unique. See Kjell Kolden, <em>Continued fractions and linear substitutions</em>, Arch. Math. Naturvid. 50 (1949), 141-196.<br>
The number n of matrices in the product U<sub>0</sub> <img align="middle" src="../gifs/cdots.gif"> U<sub>n-1</sub> is returned. 
<li><a href="./binomial"><strong>binomial</strong></a>: <tt>binomial_p(n,k,p)</tt> finds the power of a prime p dividing the binomial coefficient <img align="top" src="../gifs/binomial.gif">.<br>
<tt>binomial(n,k)</tt> prints the prime power factorization of the binomial coefficient <img align="top" src="../gifs/binomial.gif">.<br>
<li><a href="./factorial"><strong>factorial</strong></a>: <tt>factorial_p(n,p)</tt> finds the power of a prime p dividing n!<br> 
<tt>factorial(n)</tt> finds n!<br>
<li><a href="./padic"><strong>padic</strong></a>: 
<tt>twoadic(a,n)</tt> returns the first n binary digits of a 2-adic sqroot x of a positive integer a=8k+1. Here x=1 or 5 (mod 8).<br> 
<tt>padic(a,p,n)</tt> returns the first n p-adic digits of the two p-adic sqroots x of an integer a which is a quadratic residue (mod p). Here x=b (mod p), where b<sup>2</sup>=a (mod p) and 0 &lt; b &lt; p.<br> 
<li><a href="./raney"><strong>raney</strong></a>: <tt>raney(p,q,r,s)</tt> expresses a nonsingular matrix A=[p,q;r,s] (&ne; I_2 or U=[0,1;1,0]) as a product of positive powers of R=[1,1;0,1] and L=[1,0;1,1], followed by a row-balanced matrix D=[a,b;c,d]. ie. a &lt; c &amp; b &gt; d or a &gt; c &amp; b &lt; d. The number of terms L and R is returned.<br>
With U<sub>a</sub>=[a,1;1,0], note that 
U<sub>a<sub>0</sub></sub>...U<sub>a<sub>2n</sub></sub>=R<sup>a<sub>0</sub></sup>L<sup>a<sub>1</sub></sup>...R<sup>a<sub>2n</sub></sup>U<sub>0</sub> and that U<sub>a<sub>0</sub></sub>...U<sub>a<sub>2n+1</sub></sub>=R<sup>a<sub>0</sub></sup>L<sup>a<sub>1</sub></sup>...L<sup>a<sub>2n+1</sub></sup>I<sub>2</sub>.
<li><a href="./davison"><strong>davison</strong></a>: <tt>davison(l,m,n)</tt> performs the algorithm of J.L. Davison's paper <em>An algorithm for the continued fraction of e<sup>l/m</sup></em>, Proceedings of the Eighth Manitoba Conference on Numerical Mathematics and Computing (Univ. Manitoba, Winnipeg, 1978), 169--179, Congress. Numer., XXII, Utilitas Math. <br>
 With n &ge; 0, we first find the n* of Davison's Proposition 4.1 and apply Raney's factorisation to A<sub>0</sub>...A<sub>k</sub>, for n* &le; k &le; n*+n.<br>
The number (count) of partial quotients of e<sup>l/m</sup> found is returned. count becomes positive for all large n.
<li><a href="./squareroot"><strong>squareroot</strong></a>: This is an improved version of <strong>sqroot</strong> and contains <tt>cornacchia(a,b,m)</tt>. This finds all positive primitive solutions of ax<sup>2</sup>+by<sup>2</sup>=m, where a &gt; 0, b &gt; 0, a+b &gt; m &gt; 0, gcd(a,b)=1=gcd(a,m). If a=b=1, we get solutions with y &le; x.<br>
r=sqroot(d,n,e) returns the solutions of x<sup>2</sup>=d (mod n).
 r is the number of solutions (mod n).
 If e=1, we print the solutions (mod reduced_modulus) as
  reduced_solution[0],...,reduced_solution[count-1].
  If e=0, solutions are not printed. Used eg. in cornacchia().
  If omega(n) &gt; 1, we use the Chinese remainder theorem after solving mod
 qglobal[i]<sup>kglobal[i]</sup>, i=0,...,omega(n)-1.
 The array solution[0],...,solution[numbr-1] consists of the solutions
 (mod n) in the range 0 &le; x &le; n/2 and is used in cornacchia().<br>
See A. Nitaj, <em>L'algorithme de Cornacchia</em>, Expositiones Mathematicae 13 (1995), 358-365.
<li><a href="./phi"><strong>phi</strong></a> now contains <tt>sigmak(k,n)</tt> and <tt>tau(n)</tt>,  where r=sigmak(k,n), k &gt; 0,n &gt; 0, returns the sum of the k-th powers of the divisors of n and u=tau(n) returns Ramanujan's tau function. <br>
We use the simplest formula for tau(n) given on page 140 of T.M. Apostol, <em>Modular functions and Dirichlet series in number theory</em>, 20-22, 140.
<li><a href="./patz"><strong>patz</strong></a>: <tt>patz(d,n,e)</tt> finds fundamental solutions for the diophantine equation x<sup>2</sup>-dy<sup>2</sup>=n, d &gt; 0, d not a perfect square. We only find the fundamental solutions for classes P satisfying P<sup>2</sup> &equiv; d (mod |n|) with 0 &le; P &le; |n|/2. <br>
e=1 is verbose and prints the partial quotients, complete quotients and convergents up to the period (resp. double period) according as the period-length of omega[j] and omega*[j] is even or odd. e=0 prints only the fundamental solutions.<br>
Needs <a href="./squareroot"><strong>squareroot</strong></a>.
<li><a href="./squareroot"><strong>squareroot</strong></a> now contains <tt>quadratic(a,b,c,n,flag)</tt>. This returns the number k of solutions of the congruence ax<sup>2</sup>+bx+c &equiv; 0 (mod n), where gcd(a,n)=1. The solutions in the range 0 &le; x &lt; n are returned as global variables quadratic_solution[0],...,quadratic_solution[k-1]. flag=1 prints the solutions.
<li><a href="./patz"><strong>patz</strong></a> now contains <tt>binary(a,b,c,n)</tt>. This solves ax<sup>2</sup>+bxy+cy<sup>2</sup>=n, where n is non-zero and b<sup>2</sup>-4ac is positive and not a perfect square. The method is from the paper <em>The Diophantine equation ax<sup>2</sup>+bxy+cy<sup>2</sup>=N, D=b<sup>2</sup>-4ac &gt; 0</em>, Journal de Th&eacute;orie des Nombres de Bordeaux, <b>14</b> (2002) 257-270 by K.R. Matthews.
<li><a href="./decimal2rational"><strong>decimal2rational</strong></a>. 
Typing <tt>d2r(pre[],per[],k,r,b)</tt> will output the rational number with base b preperiod given by pre[k-1],...,pre[0]  (if present) and period per[r-1],...,per[0] consisting of integers in the range [0,b-1].<br>
If there is no preperiod, we let pre[0]=0 and k=0.<br>
Example: Take pre[0]=0, per[0]=2, per[1]=1, k=0, r=2, b=10.<br>
Then typing <tt>d2r(pre[],per[],k,r,b)</tt> outputs .1212&middot;&middot;&middot;=4/33.
<li><a href="./sqrtd_period"><strong>sqrtd_period</strong></a>.  Typing <tt>z=period(d)</tt> outputs the period-length z of the continued fraction of &radic;d. We use the Pohst-Zassenhaus half-period trick. See <a href="http://www.numbertheory.org/pdfs/pell.pdf">paper</a>.
<li><a href="./nipell"><strong>nipell</strong></a>. (a) Typing <tt>nipell(61,0)</tt> finds the smallest solution of Pell equation x<sup>2</sup>-61y<sup>2</sup>=1 or -1, using the nearest integer continued fraction of &radic;61.  The period (or semi-period in the case that the negative Pell equation is soluble) is also printed.<br>
Typing <tt>nipell(61,1)</tt>  prints partial quotients, complete convergents and convergents.<br>
(b) Typing <tt>nicf_pqa(d,t,u,v,e)</tt>, e=0 or 1, finds the nearest integer continued fraction of (u + t&radic;d)/v of Hurwitz.<br>
Typing <tt>nicf_pqa0(d,t,u,v,e)</tt>, e=0 or 1, finds the nearest integer continued fraction of (u + t&radic;d)/v in Perron's book.  When e=1, the period partial numerators and denominators are in capitals.<br>
<li><a href="./nscf_pell"><strong>nscf_pell</strong></a>. This program solves the Pell equations x<sup>2</sup> - dy<sup>2</sup> = &plusmn;1, using the NSCF algorithm - nearest square continued fraction algorithm.  We follow the algorithm of <a href="http://www.ms.uky.edu/~sohum/AAK/PRELUDE.htm">A.A. Krisnaswami Ayyangar</a>.<br>
(a) Typing <tt>nscf_pell(d,1)</tt> prints the partial quotients, convergents, complete convergents of the period of the nearest square continued fraction of sqrt(d), as well as the Pell equation solutions, whereas <tt>nscf_pell(d,0)</tt> prints only the  continued fraction and solutions of the Pell equation.<br>
(b) Typing <tt>nscf_pqa(d,t,u,v)</tt>, finds the nearest square continued fraction of (u + t&radic;d)/v and prints the complete quotients, convergents and partial quotients.  This latest version (25th November 2010) uses a test <tt>jpr_test2(d,p,q)</tt> for a quadratic surd to be reduced, that is better than the original definition was used in the first version.
P
<li><a href="./spiral"><strong>spiral</strong></a>. This calculates the spiral of <a href="http://www-cs-faculty.stanford.edu/~uno/gkp.html"><em>Concrete Mathematics</em></a>, Graham, Knuth, Patashnik,  Exercise 40, page 99. Needs <strong>gcd</strong>.  Type <tt>spiral(n)</tt> and then x(n) and y(n) to get the coordinates of the n-th point of the spiral.  Typing <tt>n=inverse_spiral(x,y)</tt> gives the inverse function.
<li><a href="./equivalent"><strong>equivalent</strong></a>. This produces a quadratic surd &eta;=(A+&radic;d)/C=(p&xi;+q)/(r&xi;+s), where &xi;=(a+&radic;d)/c
and &Delta;=ps-qr=&plusmn;1. Here A=&Delta;(prt+a(qr+ps)+qsc), C=&Delta;(r<sup>2</sup>t+2rsa+s^c) and t=(a<sup>2</sup>-d)/c. If &xi; is in standard form, so is &eta;. Type <tt>equiv(a,c,d,p,q,r,s)</tt>.
<li><a href="./ocf"><strong>ocf</strong></a>. Typing <tt>ocf_pqd2(d,t,u,v)</tt> constructs the optimal continued fraction of (u + t&radic;d)/v as far as the end of the first period.  Typing <tt>ocf_pqd(d,t,u,v,n)</tt> gives the OCF as far as the n-th complete quotient. In addition the h() and n() functions are printed.
<li><a href="./fibonacci"><strong>fibonacci</strong></a>. 
Typing <tt>f(m,n)</tt> produces the Fibonacci numbers F<sub>i</sub> in the interval [m,n], where 1 &le; m,n.
Typing <tt>l(m,n)</tt> produces the Lucas numbers L<sub>i</sub> in the interval [m,n], where 1 &le; m,n.
<li><a href="./carmichael"><strong>carmichael</strong></a>.  Needs to be run with <strong>phi</strong> and <strong>lucas</strong>.  Typing <tt>carmichael(n,0)</tt> solves &phi;(x)=n, where &phi;(x) is Euler'd totient function. Typing <tt>carmichael(n,1)</tt> tests <a href="../php/carmichael.html">Carmichael's conjecture</a>. Typing <tt>carmichael_nodes(n)</tt> also prints the (index: p,&gamma;,e) of the <a href="http://en.scientificcommons.org/43507001">paper</a> by Contini, Croot and Shparlinski, together with the corresponding m such that &phi(m) divides n.
</ol>
<p>
<i><a href="mailto:webmaster@numbertheory.org">Email</a></i>
<br>
<i><a href="./gnubc.html">Return to BC main page</a><br></i>
<i><a href="http://www.numbertheory.org/keith.html">http://www.numbertheory.org/keith.html</a></i><p>
<em> Last modified 17th March 2011</em>
</body>
</html>
